<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<meta name="author" content="Chris Johnson">
	<title>ComputerCard web interface demo</title>
	
	<meta name="description" content="Web interface demo for ComputerCard, for the Music Thing Modular Workshop System Computer">

	
	<script lang="javascript">


	  /*
		Fairly minimal web interface demo using WebMIDI and SysEx
		to transfer data both ways between Workshop System and the browser.


		Both the Javascript in interface.html and C++ firmware in main.cpp
		provide two functions:
		   SendSysEx
           ProcessIncomingSysEx
		which take an array of bytes (values 0 to 127) and provide bidirectional
		communication between the web interface and WS Computer firmware.

		On in both the Javascript and C++ sides, developers should fill out
		out an implementation of ProcessIncomingSysex to handle the incoming
		messages, and call SendSysEx to send messages.


		When SendSysEx is called on the WS Computer, the ProcessIncomingSysEx 
		function is called on the web interface, with the same data.

		And vice versa, if SendSysEx is called by the web interface,
		ProcessIncomingSysex is then called on the WS computer, with this data.


		Here a very simple protocol is used where the first byte of the message
		is used to indicate what type of message it is (not really necessary
		here as there is only one type of message going in each direction).
		All sorts of alternatives are possible, including sending 
		(7-bit ascii) text such as JSON.


		In a real card, it would also be sensible to have messages for checking
		that the card is correct and version number is consistent between
		HTML interface and firmware.

	   */

	  ////////////////////////////////////////////////////////////
	  // This code is fairly generic code that might be present
	  // in many web interfaces. It sets up the MIDI connection to the
	  // WS computer, and provides the SendSysEx function.

	  // InterfaceName corresponds to the USB product descriptor string -
	  // see usb_descriptors.c
	  const interfaceName = "MTMComputer";

	  
	  var midiOutput = null, midiInput = null;
	  var midiActive = false;
	  
      // MIDI Setup                                                                                               
	  async function MIDISetup()
	  {
		  try
		  {
			  const midiAccess = await navigator.requestMIDIAccess({ sysex: true });
			  midiOutput = null;
			  midiInput = null;
			  for (const output of midiAccess.outputs.values())
			  {
				  if (output.name.indexOf(interfaceName) != -1)
				  {
					  midiOutput = output;
				  }
              }                         
			  for (const input of midiAccess.inputs.values())
			  {
				  if (input.name.indexOf(interfaceName) != -1)
				  {
					  midiInput = input;

					  // Set up listener for incoming SysEx
					  midiInput.onmidimessage = (event) =>
					  {
						  const data = Array.from(event.data);
						  if (data.length>3
							  && data[0] === 0xF0
							  && data[1] === 0x7D
							  && data[data.length - 1] === 0xF7)
						  {
							  ProcessIncomingSysEx(data.slice(2, data.length-1));
						  }
					  };
				  }
              }
			  midiActive = (midiInput != null && midiOutput != null);
			  document.getElementById('connectedStatus').innerHTML = midiActive?'Connected':'No computer found';
		  }
		  catch (error)
		  {
			  document.getElementById('connectedStatus').innerHTML = 'WebMIDI error ('+error+')';
          }
      }

	  // Used to check that we're not sending data outside of permitted 0x00-0x7F range in sysex
	  function Assert7BitArray(arr, name)
	  {
		  if (!Array.isArray(arr))
		  {
			  throw new Error(`${name} must be an array`);
		  }

		  arr.forEach((v, i) =>
			  {
				  if ( v < 0 || v > 0x7F)
				  {
				  throw new Error(`${name}[${i}] is invalid (${v}). Must be integer 0â€“127.`);
				  }
			  });
	  }

	  // Wrap provided data in SysEx header/footer, and send over USB
      function SendSysEx(dataBytes)
	  {
		  if (midiActive)
		  {
			  Assert7BitArray(dataBytes, 'dataBytes');
			  midiOutput.send([0xF0,
							   0x7D,
							   ...dataBytes,
							   0xF7]);
		  }
      }

	  // All code above here is fairly generic code that might be present
	  // in many web interfaces
	  ////////////////////////////////////////////////////////////


	  
	  ////////////////////////////////////////////////////////////
	  // All code below here is specific to this particular interface

	  
	  // In this interface we start WebMIDI automatically as soon as page is loaded
	  window.onload = async function()
	  {
		  // Use 'await' here to wait until MIDISetup has finished,
		  // then enable the UI elements if connection succeeded
		  await MIDISetup();
		  if (midiActive)
		  {
			  document.getElementById('myslider').disabled = false;
		  }
	  }

	  // Called whenever slider is dragged in the HTML interface
	  function SendSliderValue(val)
	  {
		  // Send a two-byte message starting with 0x02
		  // containing the value of the slider
		  SendSysEx([0x02, val]);
	  }

	  // All interfaces would need to implement this function.
	  // Called whenever SysEx message is sent from the Workshop System to the web interface
	  function ProcessIncomingSysEx(dataBytes)
	  {
		  // If first data byte is 1, this is a message from the Workshop Computer
		  // to report the main knob position, packing the 12-bit position into
		  // the next two (7-bit) SysEx bytes.
		  if (dataBytes.length == 3 && dataBytes[0] == 0x01)
		  {
			  var mainKnob = dataBytes[1]*32 + dataBytes[2];
			  SetDialValue(mainKnob);
		  }
	  }
	  
	  // Update the fancy dial showing main knob position
	  function SetDialValue(v)
	  {
		  const MIN = 0;
		  const MAX = 4095;
		  const START_ANGLE = -142;
		  const SWEEP = 285;
		  
		  v = Number(v);
		  if (v < MIN) v = MIN;
		  if (v > MAX) v = MAX;

		  const norm = (v - MIN) / (MAX - MIN);
		  const angle = START_ANGLE + norm * SWEEP;

		  const pointer = document.getElementById("pointer");
		  pointer.setAttribute("transform", `rotate(${angle} 50 50)`);

		  document.getElementById("valueText").textContent = v;
	  }

	</script>
  </head>


  
  <body style='font-family: monospace;'>
	<div style=' width: 200px; margin: 30px auto; display:flex; flex-direction:column; justify-content: space-between; gap: 50px; text-align:center'>
	  <div>
		Status:
		<div id="connectedStatus">Disconnected</div>
	  </div>
	  <div>
		<div>
		  Drag slider and watch<br>
		  Workshop System LEDs:
		</div>
		<input id='myslider' type="range" min="0" max="127" value="0" disabled oninput="SendSliderValue(this.value)">
	  </div>
	  
	  <div>
		<div>
		  Turn the main knob<br>
		  and watch this dial:
		</div>
		<div>
		  
		  <svg id="dial" width="100" height="100" viewBox="0 0 100 100">
			<!-- dial face -->
			<circle cx="50" cy="50" r="45" fill = "#FFF" stroke="#333" stroke-width="1"/>

			<!-- pointer -->
			<line id="pointer"
				  x1="50" y1="50"
				  x2="50" y2="15"
				  stroke="#000"
				  stroke-width="2"
				  stroke-linecap="round"
				  transform="rotate(-135 50 50)" />

			<!-- center hub -->
			<circle cx="50" cy="50" r="6" fill="#333"/>

			<!-- numeric display -->
			<text id="valueText"
				  x="50" y="75"
				  text-anchor="middle"
				  font-size="9"
				  font-family="monospace">0</text>
		  </svg>
		</div>
	  </div>
	  <div>
		Run this in Chrome (or Chrome-based browsers) for WebMIDI support.<br>
		It should run on Windows/Mac/Linux/Android, but not iOS.
	  </div>
	</div>
  </body>
  

</html>
