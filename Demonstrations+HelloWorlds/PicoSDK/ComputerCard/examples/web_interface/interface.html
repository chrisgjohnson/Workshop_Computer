<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<meta name="author" content="Chris Johnson">
	<title>ComputerCard web interface demo</title>
	
	<meta name="description" content="Web interface demo for ComputerCard, for the Music Thing Modular Workshop System Computer">

	<style>
	  body
	  {
		  font-family: monospace;
	  }
	  #content
	  {
		  width: 200px;
		  margin: 30px auto;
		  display:flex;
		  flex-direction:column;
		  justify-content: space-between;
		  gap: 50px;
		  text-align:center
	  }
	  #statusDiv
	  {
		  position: absolute;
		  top: 10px;
		  right: 10px;
	  }
	</style>
	
	<script lang="javascript">


	  /*
		Web interface demo using WebMIDI and SysEx to transfer data both ways
		between Workshop System and the browser.

		Both the Javascript in interface.html and C++ firmware in main.cpp
		provide two functions:
		SendSysEx
		ProcessIncomingSysEx
		which take an array of bytes (values 0 to 127) and provide bidirectional
		communication between the web interface and WS Computer firmware.

		On in both the Javascript and C++ sides, developers should fill out
		out an implementation of ProcessIncomingSysex to handle the incoming
		messages, and call SendSysEx to send messages.


		When SendSysEx is called on the WS Computer, the ProcessIncomingSysEx 
		function is called on the web interface, with the same data.

		And vice versa, if SendSysEx is called by the web interface,
		ProcessIncomingSysex is then called on the WS computer, with this data.


		Here a very simple protocol is used where the first byte of the message
		is used to indicate what type of message it is.
		All sorts of alternatives are possible, including sending 
		(7-bit ascii) text such as JSON.

		On the firmware side, both MIDI sends and receives are designed to cope
		with long SysEx messages. This mandates an approach where the message may
		span multiple tud_midi_stream_read calls, and where tud_midi_stream_write
		may not be able to write all bytes of a message at once.
	   */

	  
	  ////////////////////////////////////////////////////////////
	  // This code is fairly generic code that might be present
	  // in many web interfaces. It sets up the MIDI connection to the
	  // WS computer, and provides the SendSysEx function.


	  // Variables to store midi input/output objects for WS computer,
	  // and boolean to indicate whether WS computer is connected.
	  var midiOutput = null, midiInput = null;
	  var midiActive = false;
	  
      // WebMIDI Setup
      // Establishes WebMIDI and sets up calls to BindDevices
	  async function MIDISetup(interfaceName, onConnect = () => {}, onDisconnect = () => {})
	  {
		  try
		  {
			  const midi = await navigator.requestMIDIAccess({ sysex: true });
			  
			  // run once at startup
			  BindDevices(midi, interfaceName, onConnect, onDisconnect);
			  
			  // run whenever devices change
			  midi.addEventListener('statechange', (e) => {
				  BindDevices(midi, interfaceName, onConnect, onDisconnect);
			  });			  
		  }
		  catch (error)
		  {
			  document.getElementById('connectedStatus').innerHTML = 'WebMIDI error ('+error+')';
          }

	  }

	  // Called on WebMIDI initialisation, and whenever a device is connected or disconnected
	  // Ignores non-WS MIDI devices, but does not handle multiple Workshop Systems.
	  function BindDevices(midi, interfaceName, onConnect, onDisconnect)
	  {
		  // If we already have a MIDI connection, check if it has been disconnected
		  if (midiActive)
		  {
			  const foundInput = [...midi.inputs.values()].some(input =>
				  input.name.includes(interfaceName) &&
					  input.state === "connected"
			  );

			  const foundOutput = [...midi.outputs.values()].some(output =>
				  output.name.includes(interfaceName) &&
					  output.state === "connected"
			  );

			  if (!foundInput || !foundOutput)
			  {
				  midiActive = false;
				  midiOutput = undefined;
				  midiInput = undefined;
				  onDisconnect();
			  }
		  }
		  else // if we don't have a MIDI connection to the WS, see if we can now create one.
		  {
			  midiInput = [...midi.inputs.values()].find(input =>
				  input.name.includes(interfaceName) &&
					  input.state === "connected");
			  
			  midiOutput = [...midi.outputs.values()].find(output =>
				  output.name.includes(interfaceName) &&
					  output.state === "connected");
			  
			  if (midiInput && midiOutput)
			  {
				  midiInput.onmidimessage = HandleMIDI;
				  midiActive = true;
				  onConnect();
			  }
			  else
			  {
				  // Clear both inputs/outputs, in the event that we only found interface for one of them
				  midiOutput = undefined;
				  midiInput = undefined;
			  }
		  }		  
	  }


	  // Called when MIDI received from Workshop system
	  function HandleMIDI(event)
	  {
		  // Send SysEx data on to ProcessIncomingSysEx. Ignore other MIDI messages.
		  const data = Array.from(event.data);
		  if (data.length>3
			  && data[0] === 0xF0
			  && data[1] === 0x7D
			  && data[data.length - 1] === 0xF7)
		  {
			  ProcessIncomingSysEx(data.slice(2, data.length-1));
		  }
	  }
	  

	  // Used to check that we're not sending data outside of permitted 0x00-0x7F range in sysex
	  function Assert7BitArray(arr, name)
	  {
		  if (!Array.isArray(arr))
		  {
			  throw new Error(`${name} must be an array`);
		  }

		  arr.forEach((v, i) =>
			  {
				  if ( v < 0 || v > 0x7F)
				  {
				  throw new Error(`${name}[${i}] is invalid (${v}). Must be integer 0â€“127.`);
				  }
			  });
	  }

	  // Wrap provided data in SysEx header/footer, and send over USB
      function SendSysEx(dataBytes)
	  {
		  if (midiActive)
		  {
			  Assert7BitArray(dataBytes, 'dataBytes');
			  midiOutput.send([0xF0,
							   0x7D,
							   ...dataBytes,
							   0xF7]);
		  }
      }

	  // All code above here is fairly generic code that might be present
	  // in many web interfaces
	  ////////////////////////////////////////////////////////////


	  
	  ////////////////////////////////////////////////////////////
	  // All code below here is specific to this particular interface

	  const MESSAGE_MAIN_KNOB_POSITION = 0x01; // firmware -> HTML
	  const MESSAGE_SLIDER_POSITION = 0x02; // HTML -> firmware
	  const MESSAGE_INTERFACE_VERSION = 0x03; // HTML -> firmware
	  const MESSAGE_FIRMWARE_VERSION = 0x04;  // firmware -> HTML
	  
	  const INTERFACE_VERSION_MAJOR = 0x00;
	  const INTERFACE_VERSION_MINOR = 0x01;
	  const INTERFACE_VERSION_PATCH = 0x00;

	  var firmwareVersionMajor=0, firmwareVersionMinor=0, firmwareVersionPatch=0;
	  
	  // In this interface we start WebMIDI automatically as soon as page is loaded
	  window.onload = function()
	  {
		  // Initialise WebMIDI and create callbacks for when computer is connected/disconnected
		  // First parameter corresponds to the USB product descriptor string -
		  // see usb_descriptors.c in the firmware
		  MIDISetup("MTMComputer", ConnectToComputer, DisconnectFromComputer);
	  }
  	
	  // Callback whenever we have found the Workshop Computer and connected to it
	  function ConnectToComputer()
	  {
		  document.getElementById('myslider').disabled = false;  
		  document.getElementById('connectedStatus').innerHTML = '<span style="color:green">Connected</span>';
		  SendVersionNumber();
	  }
	  
	  // Callback whenever the Workshop Computer is disconnected
	  function DisconnectFromComputer()
	  {
		  document.getElementById('myslider').disabled = true;
		  document.getElementById('connectedStatus').innerHTML = '<span style="color:red">Disconnected</span>';
		  DisplayVersionNumbers();
	  }

	  
	  // All interfaces would need to implement this function.
	  // Called whenever a SysEx message is sent from the Workshop System to the web interface
	  function ProcessIncomingSysEx(dataBytes)
	  {
		  // Messages from the Workshop Computer

		  // Report the main knob position, packing the 12-bit position into
		  // the next two (7-bit) SysEx bytes.
		  if (dataBytes[0] == MESSAGE_MAIN_KNOB_POSITION && dataBytes.length == 3)
		  {
			  var mainKnob = dataBytes[1]*32 + dataBytes[2];
			  SetDialValue(mainKnob);
		  }

		  // Report the firmware version number
		  if (dataBytes[0] == MESSAGE_FIRMWARE_VERSION && dataBytes.length == 4)
		  {
			  firmwareVersionMajor = dataBytes[1];
			  firmwareVersionMinor = dataBytes[2];
			  firmwareVersionPatch = dataBytes[3];
			  DisplayVersionNumbers();
		  }
	  }

	  
	  // Sent interface version number.
	  // Called when connection to computer is established
	  function SendVersionNumber()
	  {
		  SendSysEx([MESSAGE_INTERFACE_VERSION,
					 INTERFACE_VERSION_MAJOR,
					 INTERFACE_VERSION_MINOR,
					 INTERFACE_VERSION_PATCH]);
	  }

	  // Send HTML slider value
	  // Called whenever slider is dragged in the HTML interface
	  function SendSliderValue(val)
	  {
		  SendSysEx([MESSAGE_SLIDER_POSITION, val]);
	  }

	  
	  // Display version numbers in the top-right of the interface
	  function DisplayVersionNumbers()
	  {
		  d = document.getElementById('versionDiv');
		  d.innerHTML = 'Interface: v' +
			  INTERFACE_VERSION_MAJOR + '.' +
			  INTERFACE_VERSION_MINOR + '.' +
			  INTERFACE_VERSION_PATCH + '<br>'
			  +'Firmware: ';
		  if (midiActive)
		  {
			  d.innerHTML += 'v' + firmwareVersionMajor
				  + '.' + firmwareVersionMinor
				  + '.' + firmwareVersionPatch;
		  }
		  else
		  {
			  d.innerHTML += 'N/A';
		  }
	  }

	  // Update the dial showing main knob position
	  function SetDialValue(v)
	  {
		  const angle = ((v/4095)-0.5)*285;
		  document.getElementById("pointer").setAttribute("transform", `rotate(${angle} 50 50)`);
		  document.getElementById("valueText").textContent = v;
	  }

	</script>
  </head>


  
  <body>
	
	<!-- Status indicator in top right corner -->
	<div id="statusDiv">
	  <div id="connectedStatus">Loading...</div>
	  <div id="versionDiv"></div>
	</div>

	
	<div id='content'>

	  <div>
		Drag slider and watch<br>
		Workshop System LEDs:
		<input id='myslider' type="range" min="0" max="127" value="0" disabled oninput="SendSliderValue(this.value)">
	  </div>
	 
	  <div>
		Turn the main knob<br>
		and watch this dial:
		<svg id="dial" width="100" height="100" viewBox="0 0 100 100">
		  <!-- dial face -->
		  <circle cx="50" cy="50" r="45" fill = "#FFF" stroke="#888" stroke-width="1"/>

		  <!-- pointer -->
		  <line id="pointer"
				x1="50" y1="50"
				x2="50" y2="15"
				stroke="#000"
				stroke-linecap="round"
				stroke-width="3"/>
		  
		  <!-- numeric display -->
		  <text id="valueText"
				x="50" y="85"
				text-anchor="middle"
				font-size="9"
				font-family="monospace"></text>
		</svg>
	  </div>
	  
	  <div>
		Run this in Chrome (or Chrome-based browsers) for WebMIDI support.
		It should run on Windows, Mac, Linux and Android, but not iOS.
	  </div>
	  
	</div>
  </body>
  

</html>
